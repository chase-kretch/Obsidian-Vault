
### Lecture 04 Virtual Machines 2

- Virtualisation Implementation
	- Generally difficult to make a exact duplicate of a machine
		- Especially if only dual mode on CPU
		- CPU features and support for VMMs (Virtual Machine Manager), it is getting easier
	- Most VMMs implement virtual CPU to represent states of each VM
		- When guest context switched onto CPU by manager, information from VCPU is loaded and storage
- Trap and Emulate
	- Dual mode CPU: virtual machine guest executes in usermode
	- Just as the physical machine has two modes, so much the VM
		- VM needs two modes, V usermode and V Kernel mode, both run in real user mode
	- Actions in guest that usually cause switch to kernel mode must cause switch to VKM
	- Attempting priviledge instruction in user mode causes and error (trap)
	- VMM gains control, checks error, and executes operation as attempted by guest (emulate)
	- Return control to guest in user mode
	- User mode code in guest runs at same speed as if not a guest
		- Kernel mode code instead runs slower due to trap and emulate
		- Especially when multiple guests are running, (each need trap and emulate)
	 - Now that there is support for VMMs, CPUs tend to do this far better.
- Virtualization Problems
	- Some cpus dont have clean separation between privileged and nonprivileged instructions
		- Earlier x86 CPUs
		- x86 popf
			- Load CPU flags register from contents of the stack
			- If CPU in privileged mode, all flags replaced
			- If user mode, only some are replaced
			- No trap generated
	- Special Instructions caused:
		- Until 1998, trap-emulate was considered impossible
		- **Binary Translation** solves this
			- If guest VCPU is in usermode, guest can run instructions natively.
			- If kernel mode,
				- VMM examines every instruction guest is about to execute by reading ahead
				- Non special instructions run natively
				- Special instructions translated at runtime into new instructions that do equivalent task
		- Not slow because
			- Translation is simple
			- Only translates code that is ran
			- Much is the same as original
			- Cached and reused
			- Other tricks
	- **Memory Management**
		- Another challenge.
		- How can a VMM keep page table state for both guests believing they control the page and VMM that controls the tables
		- Commonly used **nested page tables (NPTs)**
			- For trap and emulated and binary translation.
			- Each guest maintains page tables to translate virtual to physical address
			- VMM maintains per guest NPT to represt guest page table
			- Just as VPU stores guest CPU state
			- When guest CPU, VMM makes the guests NPT the active page table
			- Causes TLB misses, slow performance
	- **Hardware**
		- All virtualisation needs some HW support
		- Intel added VT-x AMD AMD-V (2005 2006)
			- CPUs with this dont need binary translation
			- Defines more CPU modes, guest host
		- HW support for NPT, DMA and interrupts.
- **More VM styles**
	- Application Containment (OS Level Virtualisation)
		- Good for servers (use same OS)
		- Containers look like servers, they can be rebooted separately, have their own ip, root, programs, but use **same kernel**.
	- Paravirtualisation
		- Xen - requires modifying OS source code to use xen layer, guest knows it is running off a host.
	- Application Virtualisation
		- Application runs on a layer which provides resources it needs even though it may be running on a different OS. Wine for running programs from old windows on a newer one. (Wine is not an emulator)
	- Programming-Environment Virtualisation
		- Java Vm, CLR/MONO
		- Implement different architecture on top of hardware /OS
	- Windows Subsystem for Linux 

## Lecture 05 Systems Programming Language

- C is the language of choice for majority of OS.
	- High level assembler, can do low level things such as accessing and modifying memory.
	- Also is portable (can be used on different architectures)
	- ![[Pasted image 20240729012552.png]]
- Accessing Registers
	- You can use the register storage class specifier to say that a variable should be kept in the register e.g
		- register long number = 1234
	- However this doesnt guarantee that the value is stored in the register, it depends on how many available registers there are
	- Also, compilers are good at optimising register usage and it isnt a good idea for a programmer to manually do this
	- memory mapped registers can be accessed directly using pointer manipulation
- Volatile
	- Volatile is a type qualifier
		- volatile unsigned char *reg
		- This means the variable may change in a non local way, or that the compiler has no way of knowing whether the value has changed or not between references
		- Compiler is not allowed to optimise accesses. Ever read must go back to the main store to retrieve the current value
			- memory mapped device registers
			- values modified in interrupt routines
			- values modified in another thread
- Memory Management
	- All local variables disappear when functions are returned
		- Space is allocated on the stack for the variables in each function invocation
		- There is a limit to stack size soft limites asnd hard limits. 
	- Areas of static memory
		- Global Variables
		- Static variables
		- If in a function it maintains its value even when the function is returned. Where is the variable actually stored?
	- The advantage of static memory is that it is allocated at compile time and hence has no allocation overhead at ruin time.
	- The disadvantage is that it cannot easily be released.
- Dynamic Memory
	- C requires explicit control of dynamic memory
		- This is suitable for OS programming as there is no garbage collection available
		- garbage collection adds a layer of complexity and unpredictability to the programming environment
		- this is important in small systems such as embedded systems (or phones)
		- especially important in real-time syustems
		- malloc or callic
		- free(thread)

## Lecture 8
- Process Control Block (PCB)
	- Information associated with each process (also called task control block)
	- Where the OS can find all the information it needs to know about a process
		- Process identified and manged via a process identifier (pid)
		- Process state, running waiting, etc
		- Program counter
		- CPU registers
			- contents of all process-centric registers
		- CPU scheduling information
			- priorities, scheduling queue pointers
		- Memory-management information
			- memory allocated to the process
		- Accounting information
			- CPU used, clock time elapse since start, time limits
		- I/O status
			- I/O devices allocated to process, list of open files
	- Doesnt have to be kept together
	- ![[Screenshot 2024-08-01 at 2.14.05 PM.png]]
- UNIX PCBs
	- The PCB is the box labelled process structure but the user structure maintains some of the information as well (only required when the process is resident)
	- ![[Screenshot 2024-08-01 at 2.16.05 PM.png]]
- Windows NT PCBs
	- Information is scattered in a variety of objects
	- Executive Process Block (EPROCESS) includes:
		- KPROCESS and PEB (Process Environment Block)
			- KPROCESS includes info the kernel needs to scheduele threads
				- Kernel and user times
				- Pointers to threads
				- Priority information
				- 
			
		- Points to threads
		- Priotity information
- ![[Screenshot 2024-08-01 at 2.23.03 PM.png]]
- Linked together with a doubley linked list
- Process State
	- As a process executes it changes state
		- New: the process is being created
		- Running: being executed
		- Waiting: pending for some event to occur
		- Ready: the process is waiting to be assigned to a processor
		- Terminated: finished executing
		- ![[Screenshot 2024-08-01 at 2.25.22 PM.png]]
- Process Creation
	- Different methods of creating processes
		- Create process system call
			- takes a program name or a stream with the program data
			- windows
		- copy process system call
			- A strange way of doing it but is now very widespread thanks to UNIX
		- Create a new terminal session
		- Requires
			- A spare or new PCB
			- mark it new
			- generate a unique identifier
			- get some memory (what if there isnt any) or
			- fill in page table entries
			- set up PCB fields with initial values
			- set priority and resource limits
			- change state to ready
			- can be done by inserting into a queue of runnable processes
		- What about other resources?
			- Some OS' carefully allocate resources before a process runs (this prevents deadlock later)
			- Others leave these to the process to collect as it runs
		- Address space
			- Child duplicate of parent 
				- each one has its own copy of any data
				- Child has a new program loaded into it
			- UNIX Examples
				- fork() system call creates a new process
				- exec() system call used after a fork() to replace the processes memory space with a new program
				- Parent process calls wait() waiting for the child to terminate
				- ![[Screenshot 2024-08-01 at 2.35.45 PM.png]]
	- UNIX Fork() Call
		- Parent process
			- the one who made the call
		- Child
			- new process
		- Traditionally memory was duplicated - the code was shared even from earliest days
			- Share open files as well
			- Open file information will have the count of processes using them increases by one
			- And shared memory regions
			- Fork returns 0 in the child process and the childs pid in the parent
			- ![[Screenshot 2024-08-01 at 2.40.05 PM.png]]
			- ![[Screenshot 2024-08-01 at 2.48.51 PM.png]]
			- 6 times
	- Exec() System call
		- Checks to see if the file is executable
		- saves any parameters in some system memory
		- releases currently held memory
		- loads the program
		- moves the save parameters into the stack space of the new program
		- ready to run again
	- Fork used to copy the data memory of the process
	- If the child is going to do na exec this is a waste of effort
	- particularly bad with virtual memory
	- 